using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq.Expressions;
using NHibernate.Linq.Visitors;
using Remotion.Linq;
using Remotion.Linq.Clauses;
using Remotion.Linq.Clauses.Expressions;

namespace NHibernate.Linq.Clauses
{
	/// <summary>
	/// All joins are created as outer joins. An optimization in <see cref="WhereJoinDetector"/> finds
	/// joins that may be inner joined and calls <see cref="MakeInner"/> on them.
	/// <see cref="QueryModelVisitor"/>'s <see cref="QueryModelVisitor.VisitAdditionalFromClause"/> will
	/// then emit the correct HQL join.
	/// </summary>
	public class NhJoinClause : IBodyClause, IQuerySource
	{
		private string _itemName;
		private System.Type _itemType;
		private Expression _fromExpression;

		public NhJoinClause(string itemName, System.Type itemType, Expression fromExpression)
			: this(itemName, itemType, fromExpression, new NhWithClause[0])
		{
		}

		public NhJoinClause(string itemName, System.Type itemType, Expression fromExpression, IEnumerable<NhWithClause> restrictions)
		{
			ArgumentUtility.CheckNotNullOrEmpty("itemName", itemName);
			ArgumentUtility.CheckNotNull("itemType", itemType);
			ArgumentUtility.CheckNotNull("fromExpression", fromExpression);
			_itemName = itemName;
			_itemType = itemType;
			_fromExpression = fromExpression;

			Restrictions = new ObservableCollection<NhWithClause>();
			foreach (var withClause in restrictions)
				Restrictions.Add(withClause);
			IsInner = false;
		}

		public ObservableCollection<NhWithClause> Restrictions { get; }

		public bool IsInner { get; private set; }

		/// <summary>
		/// Gets or sets a name describing the items generated by this from clause.
		/// 
		/// </summary>
		/// 
		/// <remarks>
		/// Item names are inferred when a query expression is parsed, and they usually correspond to the variable names present in that expression.
		///             However, note that names are not necessarily unique within a <see cref="T:Remotion.Linq.QueryModel"/>. Use names only for readability and debugging, not for
		///             uniquely identifying <see cref="T:Remotion.Linq.Clauses.IQuerySource"/> objects. To match an <see cref="T:Remotion.Linq.Clauses.IQuerySource"/> with its references, use the
		///             <see cref="P:Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression.ReferencedQuerySource"/> property rather than the <see cref="P:Remotion.Linq.Clauses.FromClauseBase.ItemName"/>.
		/// 
		/// </remarks>
		public string ItemName
		{
			get { return _itemName; }
			set { _itemName = ArgumentUtility.CheckNotNullOrEmpty("value", value); }
		}

		/// <summary>
		/// Gets or sets the type of the items generated by this from clause.
		/// 
		/// </summary>
		/// <note type="warning">Changing the <see cref="P:Remotion.Linq.Clauses.FromClauseBase.ItemType"/> of a <see cref="T:Remotion.Linq.Clauses.IQuerySource"/> can make all <see cref="T:Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression"/> objects that
		///             point to that <see cref="T:Remotion.Linq.Clauses.IQuerySource"/> invalid, so the property setter should be used with care.
		///             </note>
		public System.Type ItemType
		{
			get { return _itemType; }
			set { _itemType = ArgumentUtility.CheckNotNull("value", value); }
		}

		/// <summary>
		/// The expression generating the data items for this from clause.
		/// 
		/// </summary>
		public Expression FromExpression
		{
			get { return _fromExpression; }
			set { _fromExpression = ArgumentUtility.CheckNotNull("value", value); }
		}

		public IBodyClause Clone(CloneContext cloneContext)
		{
			ArgumentUtility.CheckNotNull("cloneContext", cloneContext);
			var joinClause = new NhJoinClause(ItemName, ItemType, FromExpression);
			foreach (var withClause in Restrictions)
			{
				joinClause.Restrictions.Add(new NhWithClause(withClause.Predicate));
			}

			cloneContext.QuerySourceMapping.AddMapping(this, new QuerySourceReferenceExpression(joinClause));

			return joinClause;
		}

		public void MakeInner()
		{
			IsInner = true;
		}

		public void TransformExpressions(Func<Expression, Expression> transformation)
		{
			ArgumentUtility.CheckNotNull("transformation", transformation);
			foreach (var withClause in Restrictions)
				withClause.TransformExpressions(transformation);
			FromExpression = transformation(FromExpression);
		}

		/// <summary>
		/// Accepts the specified visitor by calling its <see cref="M:Remotion.Linq.IQueryModelVisitor.VisitAdditionalFromClause(Remotion.Linq.Clauses.AdditionalFromClause,Remotion.Linq.QueryModel,System.Int32)"/> method.
		/// 
		/// </summary>
		/// <param name="visitor">The visitor to accept.</param><param name="queryModel">The query model in whose context this clause is visited.</param><param name="index">The index of this clause in the <paramref name="queryModel"/>'s <see cref="P:Remotion.Linq.QueryModel.BodyClauses"/> collection.</param>
		public void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index)
		{
			ArgumentUtility.CheckNotNull("visitor", visitor);
			ArgumentUtility.CheckNotNull("queryModel", queryModel);
			((INhQueryModelVisitor)visitor).VisitNhJoinClause(this, queryModel, index);
		}

		IBodyClause IBodyClause.Clone(CloneContext cloneContext)
		{
			return Clone(cloneContext);
		}

		public override string ToString()
		{
			return string.Format("join {0} {1} in {2}", ItemType.Name, ItemName, FromExpression);
		}
	}
}